# Display and refresh the output of a given command in a terminal pane

# This is NOT a shell script; it's a function for use in a zsh environment.
# To add it to your shell, you'll need to copy everything below to your .zshrc file,
# and then reload it with `source ~/.zshrc`

# Usage:
#   pane [--interval SECONDS|-n SECONDS] 
#        [--exec 'SHELL COMMAND' | -e 'SHELL COMMAND']
#        [--] <command> [arg1 ...]

pane() {
  # default refresh time = 300s
  local interval=300
  local args=()
  local parsing_flags=1
  local exec_str=""

  # parse the flags in the command (more robust)
  while [[ $# -gt 0 ]]; do
    if (( parsing_flags )); then
      case "$1" in
        --)                       # -- marks explicit end of pane flags
          shift
          args=("$@")
          break
          ;;
        --interval=*)             # Allow = sign in flag just in case, e.g. --interval=180
          interval="${1#*=}"
          shift
          ;;
        --interval|-n)            # --interval 180 | -n 180
          [[ $# -lt 2 ]] && { echo "Missing value for $1" >&2; return 1; }
          interval="$2"
          shift 2
          ;;
        -n[0-9]*)                 # Allow most compact version -n180
          interval="${1#-n}"
          shift
          ;;
        --exec=*|-e=*)            # allow --exec and -e to work with =
          exec_str="${1#*=}"
          shift
          ;;
        --exec|-e)                # --exec 'cmd line...' | -e 'cmd line...'
          [[ $# -lt 2 ]] && { echo "Missing value for $1" >&2; return 1; }
          exec_str="$2"
          shift 2
          ;;          
        -*)                       # any other dash option means: command starts here
          parsing_flags=0
          args=("$@")
          break
          ;;
        *)                        # first non-flag token = command
          parsing_flags=0
          args=("$@")
          break
          ;;
      esac
    else
      args=("$@")
      break
    fi
  done

  # if run without flags, return a helpful message
  if [[ -z "$exec_str" && ${#args[@]} -eq 0 ]]; then
    echo "pane [--interval SECONDS|-n SECONDS] [--exec 'SHELL COMMAND' | -e 'SHELL COMMAND'] [--] <command> [arg1 ...]" >&2
    return 1
  fi

  # hide cursor; restore on exit
  tput civis 2>/dev/null || true
  trap 'tput cnorm 2>/dev/null || true; echo; return' INT TERM EXIT

  while true; do
    # fast clear + move cursor home
    printf '\e[H\e[2J'
    # uncomment this bit to print a tiny header
    # printf '[%s] running: %s\n\n' "$(date '+%H:%M:%S')" "${(j: :)args}"

    # Different execution for --exec vs. a standard command on the end...
    if [[ -n "$exec_str" ]]; then
      # Run the --exec command through a real zsh shell; pipes, redirection etc. will work
      zsh -lc "$exec_str"
    else
      # Direct argv execution; fine for most things, it's a real TTY so colours / ANSI etc. preserved.
      "${args[@]}"
    fi

    sleep "$interval"
  done
}
